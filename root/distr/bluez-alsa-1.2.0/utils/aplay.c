/*
 * BlueALSA - aplay.c
 * Copyright (c) 2016-2017 Arkadiusz Bokowy
 *
 * This file is a part of bluez-alsa.
 *
 * This project is licensed under the terms of the MIT license.
 *
 */

#if HAVE_CONFIG_H
# include "config.h"
#endif

#include <getopt.h>
#include <poll.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <alsa/asoundlib.h>

#include "shared/ctl-client.h"
#include "shared/log.h"


bool main_loop_on = true;
static void main_loop_stop(int sig) {
	/* Call to this handler restores the default action, so on the
	 * second call the program will be forcefully terminated. */

	struct sigaction sigact = { .sa_handler = SIG_DFL };
	sigaction(sig, &sigact, NULL);

	main_loop_on = false;
}

static int set_hw_params(snd_pcm_t *pcm, int channels, int rate,
		unsigned int *buffer_time, unsigned int *period_time) {

	snd_pcm_hw_params_t *params;
	int dir;
	int err;

	snd_pcm_hw_params_alloca(&params);

	if ((err = snd_pcm_hw_params_any(pcm, params)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_access(pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_format(pcm, params, SND_PCM_FORMAT_S16_LE)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_channels(pcm, params, channels)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_rate(pcm, params, rate, 0)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_buffer_time_near(pcm, params, buffer_time, &dir)) != 0)
		return err;
	if ((err = snd_pcm_hw_params_set_period_time_near(pcm, params, period_time, &dir)) != 0)
		return err;
	if ((err = snd_pcm_hw_params(pcm, params)) != 0)
		return err;

	return 0;
}

static int set_sw_params(snd_pcm_t *pcm, snd_pcm_uframes_t buffer_size, snd_pcm_uframes_t period_size) {

	snd_pcm_sw_params_t *params;
	int err;

	snd_pcm_sw_params_alloca(&params);

	if ((err = snd_pcm_sw_params_current(pcm, params)) != 0)
		return err;
	/* start the transfer when the buffer is full (or almost full) */
	snd_pcm_uframes_t threshold = (buffer_size / period_size) * period_size;
	if ((err = snd_pcm_sw_params_set_start_threshold(pcm, params, threshold)) != 0)
		return err;
	/* allow the transfer when at least period_size samples can be processed */
	if ((err = snd_pcm_sw_params_set_avail_min(pcm, params, period_size)) != 0)
		return err;
	if ((err = snd_pcm_sw_params(pcm, params)) != 0)
		return err;

	return 0;
}

int main(int argc, char *argv[]) {

	int opt;
	const char *opts = "hVvi:d:";
	const struct option longopts[] = {
		{ "help", no_argument, NULL, 'h' },
		{ "version", no_argument, NULL, 'V' },
		{ "verbose", no_argument, NULL, 'v' },
		{ "hci", required_argument, NULL, 'i' },
		{ "pcm", required_argument, NULL, 'd' },
		{ "pcm-buffer-time", required_argument, NULL, 3 },
		{ "pcm-period-time", required_argument, NULL, 4 },
		{ "profile-a2dp", no_argument, NULL, 1 },
		{ "profile-sco", no_argument, NULL, 2 },
		{ 0, 0, 0, 0 },
	};

	unsigned int verbose = 0;
	const char *device = "default";
	const char *ba_interface = "hci0";
	unsigned int pcm_buffer_time = 500000;
	unsigned int pcm_period_time = 100000;
	enum pcm_type ba_type = PCM_TYPE_A2DP;

	while ((opt = getopt_long(argc, argv, opts, longopts, NULL)) != -1)
		switch (opt) {
		case 'h' /* --help */ :
usage:
			printf("usage: %s [OPTION]... <BT-ADDR>\n\n"
					"options:\n"
					"  -h, --help\t\tprint this help and exit\n"
					"  -V, --version\t\tprint version and exit\n"
					"  -v, --verbose\t\tmake output more verbose\n"
					"  -i, --hci=hciX\tHCI device to use\n"
					"  -d, --pcm=NAME\tPCM device to use\n"
					"  --pcm-buffer-time=INT\tPCM buffer time\n"
					"  --pcm-period-time=INT\tPCM period time\n"
					"  --profile-a2dp\tuse A2DP profile\n"
					"  --profile-sco\t\tuse SCO profile\n",
					argv[0]);
			return EXIT_SUCCESS;

		case 'V' /* --version */ :
			printf("%s\n", PACKAGE_VERSION);
			return EXIT_SUCCESS;

		case 'v' /* --verbose */ :
			verbose++;
			break;

		case 'i' /* --hci */ :
			ba_interface = optarg;
			break;
		case 'd' /* --pcm */ :
			device = optarg;
			break;

		case 1 /* --profile-a2dp */ :
			ba_type = PCM_TYPE_A2DP;
			break;
		case 2 /* --profile-sco */ :
			ba_type = PCM_TYPE_SCO;
			break;

		case 3 /* --pcm-buffer-time */ :
			pcm_buffer_time = atoi(optarg);
			break;
		case 4 /* --pcm-period-time */ :
			pcm_period_time = atoi(optarg);
			break;

		default:
			fprintf(stderr, "Try '%s --help' for more information.\n", argv[0]);
			return EXIT_FAILURE;
		}

	if (optind + 1 != argc)
		goto usage;

	if (verbose >= 1)
		printf("Selected configuration:\n"
				"  HCI device: %s\n"
				"  PCM device: %s\n"
				"  PCM buffer time: %u us\n"
				"  PCM period time: %u us\n"
				"  Bluetooth device: %s\n"
				"  Profile: %s\n",
				ba_interface, device, pcm_buffer_time, pcm_period_time,
				argv[optind], ba_type == PCM_TYPE_A2DP ? "A2DP" : "SCO");

	struct msg_transport *transport = NULL;
	snd_pcm_t *pcm = NULL;
	int status = EXIT_SUCCESS;
	int ba_pcm_fd = -1;
	int ba_fd = -1;
	bdaddr_t addr;
	int err;

	log_open(argv[0], false, false);

	if (str2ba(argv[optind], &addr) != 0) {
		error("Invalid BT device address: %s", argv[optind]);
		goto fail;
	}

	if ((err = snd_pcm_open(&pcm, device, SND_PCM_STREAM_PLAYBACK, 0)) != 0) {
		error("Couldn't open PCM: %s", snd_strerror(err));
		goto fail;
	}

	if ((ba_fd = bluealsa_open(ba_interface)) == -1) {
		error("BlueALSA connection failed: %s", strerror(errno));
		goto fail;
	}

	if ((transport = bluealsa_get_transport(ba_fd, addr, ba_type, PCM_STREAM_CAPTURE)) == NULL) {
		error("Couldn't get BlueALSA transport: %s", strerror(errno));
		goto fail;
	}

	if ((err = set_hw_params(pcm, transport->channels, transport->sampling,
					&pcm_buffer_time, &pcm_period_time)) != 0) {
		error("Couldn't set HW parameters: %s", snd_strerror(err));
		goto fail;
	}

	snd_pcm_uframes_t buffer_size, period_size;
	if ((err = snd_pcm_get_params(pcm, &buffer_size, &period_size)) != 0) {
		error("Couldn't get PCM parameters: %s", snd_strerror(err));
		goto fail;
	}

	if (verbose >= 2)
		printf("Used configuration:\n"
				"  PCM buffer time: %u us (%zu bytes)\n"
				"  PCM period time: %u us (%zu bytes)\n",
				pcm_buffer_time, snd_pcm_frames_to_bytes(pcm, buffer_size),
				pcm_period_time, snd_pcm_frames_to_bytes(pcm, period_size));

	if ((err = set_sw_params(pcm, buffer_size, period_size)) != 0) {
		error("Couldn't set SW parameters: %s", snd_strerror(err));
		goto fail;
	}

	if ((err = snd_pcm_prepare(pcm)) != 0) {
		error("Couldn't prepare PCM: %s", snd_strerror(err));
		goto fail;
	}

	transport->stream = PCM_STREAM_CAPTURE;
	if ((ba_pcm_fd = bluealsa_open_transport(ba_fd, transport)) == -1) {
		error("Couldn't open PCM FIFO: %s", strerror(errno));
		goto fail;
	}

	struct sigaction sigact = { .sa_handler = main_loop_stop };
	sigaction(SIGTERM, &sigact, NULL);
	sigaction(SIGINT, &sigact, NULL);

	struct pollfd pfds[] = {{ ba_pcm_fd, POLLIN, 0 }};
	ssize_t frame_size = snd_pcm_frames_to_bytes(pcm, 1);
	char *buffer = malloc(period_size * frame_size);
	char *buffer_head = buffer;

	debug("Starting main loop");
	while (main_loop_on) {

		size_t buffer_len = period_size * frame_size - (buffer_head - buffer);
		ssize_t ret;

		/* Reading from the FIFO won't block unless there is an open connection
		 * on the writing side. However, the server does not open PCM FIFO until
		 * a transport is created. With the A2DP, the transport is created when
		 * some clients (BT device) requests audio transfer. */
		if (poll(pfds, sizeof(pfds) / sizeof(*pfds), -1) == -1 && errno == EINTR)
			continue;

		/* FIFO has been terminated on the writing side */
		if (pfds[0].revents & POLLHUP)
			break;

		if ((ret = read(ba_pcm_fd, buffer_head, buffer_len)) == -1) {
			if (errno == EINTR)
				continue;
			error("PCM FIFO read error: %s", strerror(errno));
			goto fail;
		}

		/* calculate the overall number of frames in the buffer */
		snd_pcm_uframes_t frames = ((buffer_head - buffer) + ret) / frame_size;

		if ((err = snd_pcm_writei(pcm, buffer, frames)) < 0)
			switch (-err) {
			case EPIPE:
				debug("An underrun has occurred");
				snd_pcm_prepare(pcm);
				usleep(50000);
				err = 0;
				break;
			default:
				error("Couldn't write to PCM: %s", snd_strerror(err));
				goto fail;
			}

		size_t writei_len = err * frame_size;
		buffer_head = buffer;

		/* move leftovers to the beginning and reposition head */
		if ((size_t)ret > writei_len) {
			memmove(buffer, buffer + writei_len, ret - writei_len);
			buffer_head += ret - writei_len;
		}

	}

	goto success;

fail:
	status = EXIT_FAILURE;

success:
	if (ba_pcm_fd != -1) {
		bluealsa_close_transport(ba_fd, transport);
		close(ba_pcm_fd);
	}
	free(transport);
	if (ba_fd != -1)
		close(ba_fd);
	if (pcm != NULL)
		snd_pcm_close(pcm);
	return status;
}
